import { NextResponse } from "next/server";
import { createClient } from '@supabase/supabase-js';
import { sendOrderConfirmationEmail } from '@/lib/email';

function getSupabase() {
  const url = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const key = process.env.SUPABASE_SERVICE_ROLE_KEY;
  if (!url || !key) {
    throw new Error('Missing Supabase environment variables');
  }
  return createClient(url, key, { auth: { persistSession: false } });
}

type Body = {
  channel: "veeb" | "telefon" | "FB" | "e_post";
  customer: { name:string; phone:string; email:string; org_name?:string; reg_code?:string };
  ring_id: string;
  stop_id: string;
  delivery_address?: string;
  notes_customer?: string;
  notes_internal?: string;
  payment_method: "sularaha"|"ülekandega";
  order_lines: Array< { sku:string; uom:"kg"|"tk"; ordered_qty:number; substitution_allowed?:boolean; unit_price?:number }>;
};

export async function POST(req: Request) {
  console.log('[api/orders POST] Starting order submission');
  try {
    const b = (await req.json()) as Body;
    console.log('[api/orders POST] Request body received', { 
      has_customer: !!b.customer, 
      ring_id: b.ring_id, 
      stop_id: b.stop_id, 
      order_lines_count: b.order_lines?.length 
    });
    
    // Check if Supabase is configured
    if (!process.env.NEXT_PUBLIC_SUPABASE_URL || !process.env.SUPABASE_SERVICE_ROLE_KEY) {
      console.error('[api/orders] Missing Supabase configuration');
      return NextResponse.json({
        ok: false,
        error: 'Order system is temporarily unavailable. Please contact us directly.'
      }, { status: 503 });
    }

    // 1) Validation
    if(!b?.customer?.email || !b?.customer?.phone || !b.ring_id || !b.stop_id || !b.order_lines?.length){
      return NextResponse.json({ok:false, error:"Missing required fields"}, { status: 400 });
    }

    const sb = getSupabase();

    // 2) Check ring exists and cutoff
    console.log('[api/orders POST] Checking ring:', b.ring_id);
    const { data: ring, error: ringError } = await sb
      .from('Ring')
      .select('id, region, cutoffAt, ringDate')
      .eq('id', b.ring_id)
      .single();
    
    if (ringError) {
      console.error('[api/orders POST] Ring query error:', ringError);
      return NextResponse.json({ok:false, error:`Ring not found: ${ringError.message}`},{status:404});
    }
    
    if (!ring) {
      console.error('[api/orders POST] Ring not found with id:', b.ring_id);
      return NextResponse.json({ok:false, error:"Ring not found"},{status:404});
    }
    
    console.log('[api/orders POST] Ring found:', ring.region);

    const now = new Date();
    if (ring.cutoffAt && now > new Date(ring.cutoffAt)) {
      console.log('[api/orders POST] Cutoff passed for ring');
      return NextResponse.json({ok:false, error:"Cutoff passed for this ring"},{status:422});
    }

    const isHomeDelivery = ring.region === 'Viru-Nigula-Sonda ring';

    // Generate order ID
    const orderId = `order_${Date.now()}_${Math.random().toString(36).substring(7)}`;
    console.log('[api/orders POST] Generated order ID:', orderId);

    // 3) Upsert customer first
    console.log('[api/orders POST] Upserting customer:', b.customer.email);
    const { data: existingCustomer } = await sb
      .from('Customer')
      .select('id, name, phone, email, orgName, regCode, segment')
      .eq('email', b.customer.email)
      .single();
    
    if (existingCustomer) {
      console.log('[api/orders POST] Existing customer found:', existingCustomer.id);
    }

    let customerId: string;
    if (existingCustomer) {
      // Update existing customer
      const { error: updateError } = await sb
        .from('Customer')
        .update({
          name: b.customer.name,
          phone: b.customer.phone,
          orgName: b.customer.org_name || null,
          regCode: b.customer.reg_code || null
        })
        .eq('id', existingCustomer.id);
      
      if (updateError) {
        console.error('[api/orders] Failed to update customer:', updateError);
        return NextResponse.json({ok:false, error:"Failed to update customer"},{status:500});
      }
      customerId = existingCustomer.id;
    } else {
      // Create new customer (ID will be generated by database)
      console.log('[api/orders POST] Creating new customer');
      const { data: newCustomer, error: createError } = await sb
        .from('Customer')
        .insert({
          name: b.customer.name,
          phone: b.customer.phone,
          email: b.customer.email,
          orgName: b.customer.org_name || null,
          regCode: b.customer.reg_code || null,
          segment: "RETAIL"
        })
        .select('id')
        .single();

      if (createError || !newCustomer) {
        console.error('[api/orders] Failed to create customer:', createError);
        return NextResponse.json({ok:false, error:"Failed to create customer"},{status:500});
      }
      customerId = newCustomer.id;
      console.log('[api/orders POST] New customer created with ID:', customerId);
    }

    // 4) Check for duplicate orders (last 24h) using customerId
    const { data: duplicateOrders } = await sb
      .from('Order')
      .select('id')
      .eq('customerId', customerId)
      .eq('ringId', b.ring_id)
      .eq('stopId', b.stop_id)
      .gte('createdAt', new Date(Date.now() - 24*60*60*1000).toISOString())
      .limit(1);

    const duplicateOrder = duplicateOrders && duplicateOrders.length > 0 ? duplicateOrders[0] : null;

    // 5) Create order with camelCase columns
    const channelMap: Record<string, string> = {
      "veeb": "WEB",
      "telefon": "PHONE",
      "FB": "FACEBOOK",
      "e_post": "EMAIL"
    };

    console.log('[api/orders POST] Creating order with ID:', orderId);
    const orderData = {
      id: orderId,
      channel: channelMap[b.channel] || "WEB",
      customerId: customerId,
      ringId: b.ring_id,
      stopId: b.stop_id,
      deliveryType: isHomeDelivery ? "HOME" : "STOP",
      deliveryAddress: isHomeDelivery ? b.notes_customer : (b.delivery_address || null),
      status: "NEW",
      notesCustomer: b.notes_customer || null,
      notesInternal: b.notes_internal || null,
      paymentMethod: b.payment_method === "ülekandega" ? "TRANSFER" : "CASH",
      paymentStatus: "UNPAID"
    };
    console.log('[api/orders POST] Order data:', JSON.stringify(orderData));
    
    const { data: order, error: orderError } = await sb
      .from('Order')
      .insert(orderData)
      .select('id')
      .single();

    if (orderError) {
      console.error('[api/orders] Failed to create order:', orderError);
      return NextResponse.json({ok:false, error:`Failed to create order: ${orderError.message}`},{status:500});
    }
    if (!order) {
      console.error('[api/orders] Order not returned');
      return NextResponse.json({ok:false, error:"Failed to create order"},{status:500});
    }
    console.log('[api/orders POST] Order created successfully with ID:', order.id);

    // 6) Create order lines with camelCase columns
    const orderLines = b.order_lines.map((line, index) => ({
      id: `orderline_${Date.now()}_${index}_${Math.random().toString(36).substring(7)}`,
      orderId: order.id,
      productSku: line.sku,
      uom: line.uom.toUpperCase() as 'KG' | 'TK',
      requestedQty: line.ordered_qty,
      substitutionAllowed: !!line.substitution_allowed,
      unitPrice: line.unit_price || null
    }));
    
    console.log('[api/orders POST] Creating', orderLines.length, 'order lines');

    const { error: linesError } = await sb
      .from('OrderLine')
      .insert(orderLines);

    if (linesError) {
      console.error('[api/orders] Failed to create order lines:', linesError);
      return NextResponse.json({ok:false, error:"Failed to create order lines"},{status:500});
    }

    // 7) Send order confirmation email
    try {
      // Fetch stop details for email
      const { data: stop, error: stopError } = await sb
        .from('Stop')
        .select('name')
        .eq('id', b.stop_id)
        .single();

      if (stopError || !stop) {
        console.error('[api/orders] Failed to fetch stop for email:', stopError);
        // Continue anyway - don't fail order if we can't fetch stop
      } else {
        // Fetch order lines with product details
        const { data: orderLines, error: linesFetchError } = await sb
          .from('OrderLine')
          .select('productSku, requestedQty, uom, Product:productSku(name)')
          .eq('orderId', order.id);

        if (!linesFetchError && orderLines) {
          // Build products array for email
          const products = orderLines.map((line: any) => ({
            name: line.Product?.name || line.productSku || 'Unknown product',
            sku: line.productSku,
            quantity: line.requestedQty,
            uom: line.uom?.toLowerCase() || 'kg'
          }));

          // Send confirmation email
          await sendOrderConfirmationEmail(
            b.customer.email,
            b.customer.name,
            order.id,
            {
              ring: ring.region,
              stop: stop.name,
              deliveryType: isHomeDelivery ? 'HOME' : 'STOP',
              deliveryAddress: isHomeDelivery ? b.notes_customer : undefined,
              paymentMethod: b.payment_method === "ülekandega" ? 'TRANSFER' : 'CASH',
              products: products
            }
          );
          console.log('[api/orders] Order confirmation email sent successfully');
        } else {
          console.error('[api/orders] Failed to fetch order lines for email:', linesFetchError);
        }
      }
    } catch (emailError) {
      console.error('[api/orders] Failed to send confirmation email:', emailError);
      // Don't fail the order if email fails - order was successfully created
    }

    return NextResponse.json({ 
      ok: true, 
      orderId: order.id,
      duplicate: !!duplicateOrder 
    }, { status: 200 });

  } catch (e: unknown) {
    console.error('[api/orders] exception:', e);
    const errorMsg = e instanceof Error ? e.message : String(e);
    console.error('[api/orders] error details:', errorMsg);
    return NextResponse.json({ ok:false, error: `Server error: ${errorMsg}` }, { status: 500 });
  }
}

export async function GET() {
  try {
    const sb = getSupabase();
    
    const { data: rings, error } = await sb
      .from('Ring')
      .select('id, ringDate, region, cutoffAt, status')
      .order('ringDate', { ascending: true });

    if (error) {
      console.error('[api/orders GET] error:', error);
      return NextResponse.json({ ok: false, error: "Database connection failed" }, { status: 500 });
    }
    
    return NextResponse.json({ ok: true, items: rings || [] });
  } catch (e: unknown) {
    console.error('[api/orders GET] exception:', e);
    return NextResponse.json({ ok: false, error: "Database connection failed" }, { status: 500 });
  }
}
